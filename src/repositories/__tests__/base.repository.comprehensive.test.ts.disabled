import { describe, it, expect, beforeEach, afterEach, vi } from "vitest";
import { BaseRepository } from "@repositories/base.repository";
import { IBaseEntity } from "../../types/database.types";
import { config } from "../../config/env";
import Database from "better-sqlite3";
import { v4 as uuidv4 } from "uuid";
import { SQLiteConfig } from "../../config/sqlite";

// Mock SQLiteConfig before any imports
vi.mock("../../config/sqlite", () => ({
  SQLiteConfig: {
    getClient: vi.fn(),
  },
}));

interface ITestEntity extends IBaseEntity {
  name: string;
  email: string;
}

class TestRepository extends BaseRepository<ITestEntity> {
  protected tableName = "test_entities";

  protected initializeTable(): void {
    if (config.database.provider === "sqlite") {
      const db = SQLiteConfig.getClient();
      db.exec(`
        CREATE TABLE IF NOT EXISTS ${this.tableName} (
          id TEXT PRIMARY KEY,
          name TEXT NOT NULL,
          email TEXT UNIQUE NOT NULL,
          created_at TEXT NOT NULL,
          updated_at TEXT NOT NULL,
          deleted_at TEXT
        )
      `);
    }
  }
}

describe("BaseRepository - Comprehensive Adapter Tests", () => {
  let repository: TestRepository;
  let originalProvider: string;
  let testDb: Database.Database | null = null;

  beforeEach(() => {
    originalProvider = config.database.provider;
  });

  afterEach(() => {
    // Reset provider
    config.database.provider = originalProvider as "supabase" | "sqlite";

    // Clean up test database
    if (testDb) {
      try {
        testDb.exec("DROP TABLE IF EXISTS test_entities");
        testDb.close();
      } catch (error) {
        // Ignore cleanup errors
      }
      testDb = null;
    }

    vi.clearAllMocks();
  });

  describe("SQLite Adapter Tests", () => {
    beforeEach(() => {
      // Force SQLite mode
      config.database.provider = "sqlite";

      // Create a test database
      testDb = new Database(":memory:");

      // Mock SQLiteConfig to return our test database
      vi.mock("../../config/sqlite", () => ({
        SQLiteConfig: {
          getClient: () => testDb,
        },
      }));

      repository = new TestRepository();
    });

    it("should create table during initialization", () => {
      const tables = testDb!
        .prepare(
          "SELECT name FROM sqlite_master WHERE type='table' AND name='test_entities'",
        )
        .all();
      expect(tables).toHaveLength(1);
    });

    it("should create a new entity with SQLite", async () => {
      const entityData = {
        name: "John Doe",
        email: "john@example.com",
      };

      const result = await repository.create(entityData);

      expect(result).toMatchObject({
        name: "John Doe",
        email: "john@example.com",
      });
      expect(result.id).toBeDefined();
      expect(result.createdAt).toBeDefined();
      expect(result.updatedAt).toBeDefined();
    });

    it("should find entity by ID with SQLite", async () => {
      const entityData = {
        name: "Jane Doe",
        email: "jane@example.com",
      };

      const created = await repository.create(entityData);
      const found = await repository.findById(created.id);

      expect(found).toEqual(created);
    });

    it("should return null for non-existent entity", async () => {
      const found = await repository.findById("non-existent-id");
      expect(found).toBeNull();
    });

    it("should update entity with SQLite", async () => {
      const entityData = {
        name: "Bob Smith",
        email: "bob@example.com",
      };

      const created = await repository.create(entityData);
      const updated = await repository.update(created.id, {
        name: "Bobby Smith",
      });

      expect(updated.name).toBe("Bobby Smith");
      expect(updated.email).toBe("bob@example.com");
      expect(updated.updatedAt).not.toBe(created.updatedAt);
    });

    it("should soft delete entity with SQLite", async () => {
      const entityData = {
        name: "Delete Me",
        email: "delete@example.com",
      };

      const created = await repository.create(entityData);
      await repository.softDelete(created.id);

      const found = await repository.findById(created.id);
      expect(found).toBeNull();
    });

    it("should hard delete entity with SQLite", async () => {
      const entityData = {
        name: "Hard Delete Me",
        email: "harddelete@example.com",
      };

      const created = await repository.create(entityData);
      await repository.hardDelete(created.id);

      // Check that the record is completely gone from the database
      const result = testDb!
        .prepare("SELECT * FROM test_entities WHERE id = ?")
        .get(created.id);
      expect(result).toBeUndefined();
    });

    it("should find many entities with filters", async () => {
      await repository.create({ name: "User 1", email: "user1@example.com" });
      await repository.create({ name: "User 2", email: "user2@example.com" });
      await repository.create({ name: "Admin", email: "admin@example.com" });

      const users = await repository.findMany({
        filters: { name: "User 1" },
      });

      expect(users).toHaveLength(1);
      expect(users[0].name).toBe("User 1");
    });

    it("should paginate results correctly", async () => {
      // Create multiple entities
      for (let i = 1; i <= 5; i++) {
        await repository.create({
          name: `User ${i}`,
          email: `user${i}@example.com`,
        });
      }

      const result = await repository.findWithPagination({
        pagination: { page: 1, limit: 2 },
      });

      expect(result.data).toHaveLength(2);
      expect(result.pagination.total).toBe(5);
      expect(result.pagination.hasNext).toBe(true);
      expect(result.pagination.hasPrevious).toBe(false);
    });

    it("should count entities correctly", async () => {
      await repository.create({ name: "User 1", email: "user1@example.com" });
      await repository.create({ name: "User 2", email: "user2@example.com" });

      const count = await repository.count();
      expect(count).toBe(2);
    });

    it("should check if entity exists", async () => {
      const created = await repository.create({
        name: "Exists User",
        email: "exists@example.com",
      });

      const exists = await repository.exists(created.id);
      const notExists = await repository.exists("non-existent");

      expect(exists).toBe(true);
      expect(notExists).toBe(false);
    });

    it("should find first entity matching filters", async () => {
      await repository.create({ name: "First", email: "first@example.com" });
      await repository.create({ name: "Second", email: "second@example.com" });

      const first = await repository.findFirst({ name: "First" });
      expect(first?.name).toBe("First");

      const notFound = await repository.findFirst({ name: "NonExistent" });
      expect(notFound).toBeNull();
    });

    it("should handle errors for duplicate unique constraints", async () => {
      await repository.create({ name: "User", email: "unique@example.com" });

      await expect(
        repository.create({
          name: "Another User",
          email: "unique@example.com",
        }),
      ).rejects.toThrow();
    });

    it("should exclude soft-deleted entities from queries", async () => {
      const entity1 = await repository.create({
        name: "Active",
        email: "active@example.com",
      });
      const entity2 = await repository.create({
        name: "ToDelete",
        email: "delete@example.com",
      });

      await repository.softDelete(entity2.id);

      const all = await repository.findMany();
      expect(all).toHaveLength(1);
      expect(all[0].id).toBe(entity1.id);

      const count = await repository.count();
      expect(count).toBe(1);
    });
  });

  describe("Adapter Switching", () => {
    it("should use SQLite adapter when provider is sqlite", () => {
      config.database.provider = "sqlite";
      const sqliteRepo = new TestRepository();

      // Verify SQLite is being used by checking table creation
      expect(() => sqliteRepo).not.toThrow();
    });

    it("should use Supabase adapter when provider is supabase", () => {
      config.database.provider = "supabase";

      // Mock Supabase client
      const mockSupabaseClient = {
        from: vi.fn().mockReturnValue({
          select: vi.fn().mockReturnThis(),
          insert: vi.fn().mockReturnThis(),
          update: vi.fn().mockReturnThis(),
          delete: vi.fn().mockReturnThis(),
          eq: vi.fn().mockReturnThis(),
          single: vi.fn().mockReturnThis(),
        }),
      };

      const supabaseRepo = new TestRepository(mockSupabaseClient as any);
      expect(() => supabaseRepo).not.toThrow();
    });

    it("should throw error when accessing supabase client in SQLite mode", () => {
      config.database.provider = "sqlite";
      const sqliteRepo = new TestRepository();

      expect(() => {
        // Access the protected supabase property (for testing)
        const client = (sqliteRepo as any).supabase;
        return client;
      }).toThrow("Supabase client not available in SQLite mode");
    });
  });

  describe("Data Consistency Between Adapters", () => {
    it("should produce similar data structures regardless of adapter", async () => {
      const testData = {
        name: "Consistency Test",
        email: "consistency@example.com",
      };

      // Test with SQLite
      config.database.provider = "sqlite";
      testDb = new Database(":memory:");

      vi.mock("../../config/sqlite", () => ({
        SQLiteConfig: {
          getClient: () => testDb,
        },
      }));

      const sqliteRepo = new TestRepository();
      const sqliteResult = await sqliteRepo.create(testData);

      // Verify structure
      expect(sqliteResult).toHaveProperty("id");
      expect(sqliteResult).toHaveProperty("name", "Consistency Test");
      expect(sqliteResult).toHaveProperty("email", "consistency@example.com");
      expect(sqliteResult).toHaveProperty("createdAt");
      expect(sqliteResult).toHaveProperty("updatedAt");
    });
  });
});
